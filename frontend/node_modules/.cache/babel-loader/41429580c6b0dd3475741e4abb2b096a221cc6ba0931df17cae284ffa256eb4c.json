{"ast":null,"code":"// src/utils/puzzleUtils.js\n\n/**\r\n * Generates a solvable slide puzzle.\r\n * Uses the inversion count method to ensure solvability.\r\n * For an N x N puzzle:\r\n * - If N is odd, the puzzle is solvable if the number of inversions is even.\r\n * - If N is even, the puzzle is solvable if:\r\n * - The blank is on an even row counting from the bottom (row 1, 3, 5...) AND the number of inversions is odd.\r\n * - The blank is on an odd row counting from the bottom (row 0, 2, 4...) AND the number of inversions is even.\r\n *\r\n * @param {number} level The size of one side of the square puzzle (e.g., 3 for 3x3).\r\n * @returns {number[]} An array representing the shuffled puzzle tiles.\r\n */\nexport function generateSolvablePuzzle(level) {\n  const numTiles = level * level;\n  let puzzle = Array.from({\n    length: numTiles\n  }, (_, i) => i); // [0, 1, ..., N*N-1]\n\n  let shuffledPuzzle = [];\n  let tempPuzzle = [...puzzle]; // Create a copy to shuffle\n\n  // Fisher-Yates (Knuth) shuffle\n  for (let i = tempPuzzle.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [tempPuzzle[i], tempPuzzle[j]] = [tempPuzzle[j], tempPuzzle[i]];\n  }\n  shuffledPuzzle = tempPuzzle;\n  const inversions = countInversions(shuffledPuzzle);\n  const blankTileIndex = shuffledPuzzle.indexOf(numTiles - 1);\n  const blankRowFromBottom = level - Math.floor(blankTileIndex / level);\n  let isSolvable = false;\n  if (level % 2 !== 0) {\n    isSolvable = inversions % 2 === 0;\n  } else {\n    if (blankRowFromBottom % 2 !== 0) {\n      isSolvable = inversions % 2 === 0;\n    } else {\n      isSolvable = inversions % 2 !== 0;\n    }\n  }\n  if (!isSolvable) {\n    let swapIndex1 = 0;\n    let swapIndex2 = 0;\n    if (shuffledPuzzle[0] !== numTiles - 1 && shuffledPuzzle[1] !== numTiles - 1) {\n      swapIndex1 = 0;\n      swapIndex2 = 1;\n    } else if (shuffledPuzzle[0] !== numTiles - 1 && shuffledPuzzle[2] !== numTiles - 1) {\n      swapIndex1 = 0;\n      swapIndex2 = 2;\n    } else {\n      let found = 0;\n      for (let i = 0; i < numTiles && found < 2; i++) {\n        if (shuffledPuzzle[i] !== numTiles - 1) {\n          if (found === 0) {\n            swapIndex1 = i;\n          } else {\n            swapIndex2 = i;\n          }\n          found++;\n        }\n      }\n    }\n    [shuffledPuzzle[swapIndex1], shuffledPuzzle[swapIndex2]] = [shuffledPuzzle[swapIndex2], shuffledPuzzle[swapIndex1]];\n  }\n  return shuffledPuzzle;\n}\n\n/**\r\n * Counts the number of inversions in a given puzzle array.\r\n * An inversion is a pair of tiles (a, b) where a appears before b, but a > b.\r\n * The blank tile (N*N - 1) is excluded from inversion counting.\r\n * @param {number[]} puzzle The current state of the puzzle tiles.\r\n * @returns {number} The total number of inversions.\r\n */\nfunction countInversions(puzzle) {\n  let inversions = 0;\n  const n = puzzle.length;\n  const blankTileValue = n - 1; // The value of the blank tile\n\n  for (let i = 0; i < n - 1; i++) {\n    if (puzzle[i] === blankTileValue) {\n      continue;\n    }\n    for (let j = i + 1; j < n; j++) {\n      if (puzzle[j] === blankTileValue) {\n        continue;\n      }\n      if (puzzle[i] > puzzle[j]) {\n        inversions++;\n      }\n    }\n  }\n  return inversions;\n}\n\n/**\r\n * Checks if the puzzle is in its solved state.\r\n * The solved state is when tiles are in ascending order (0, 1, 2, ..., N*N - 1).\r\n * @param {number[]} puzzle The current state of the puzzle tiles.\r\n * @param {number} level The size of one side of the square puzzle.\r\n * @returns {boolean} True if the puzzle is solved, false otherwise.\r\n */\nexport function isSolved(puzzle, level) {\n  const numTiles = level * level;\n  for (let i = 0; i < numTiles; i++) {\n    if (puzzle[i] !== i) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["generateSolvablePuzzle","level","numTiles","puzzle","Array","from","length","_","i","shuffledPuzzle","tempPuzzle","j","Math","floor","random","inversions","countInversions","blankTileIndex","indexOf","blankRowFromBottom","isSolvable","swapIndex1","swapIndex2","found","n","blankTileValue","isSolved"],"sources":["E:/ScrambleP/frontend/src/utils/puzzleUtils.js"],"sourcesContent":["// src/utils/puzzleUtils.js\r\n\r\n/**\r\n * Generates a solvable slide puzzle.\r\n * Uses the inversion count method to ensure solvability.\r\n * For an N x N puzzle:\r\n * - If N is odd, the puzzle is solvable if the number of inversions is even.\r\n * - If N is even, the puzzle is solvable if:\r\n * - The blank is on an even row counting from the bottom (row 1, 3, 5...) AND the number of inversions is odd.\r\n * - The blank is on an odd row counting from the bottom (row 0, 2, 4...) AND the number of inversions is even.\r\n *\r\n * @param {number} level The size of one side of the square puzzle (e.g., 3 for 3x3).\r\n * @returns {number[]} An array representing the shuffled puzzle tiles.\r\n */\r\nexport function generateSolvablePuzzle(level) {\r\n    const numTiles = level * level;\r\n    let puzzle = Array.from({ length: numTiles }, (_, i) => i); // [0, 1, ..., N*N-1]\r\n\r\n    let shuffledPuzzle = [];\r\n    let tempPuzzle = [...puzzle]; // Create a copy to shuffle\r\n\r\n    // Fisher-Yates (Knuth) shuffle\r\n    for (let i = tempPuzzle.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [tempPuzzle[i], tempPuzzle[j]] = [tempPuzzle[j], tempPuzzle[i]];\r\n    }\r\n    shuffledPuzzle = tempPuzzle;\r\n\r\n    const inversions = countInversions(shuffledPuzzle);\r\n    const blankTileIndex = shuffledPuzzle.indexOf(numTiles - 1); \r\n    const blankRowFromBottom = level - Math.floor(blankTileIndex / level); \r\n    let isSolvable = false;\r\n\r\n    if (level % 2 !== 0) { \r\n        isSolvable = (inversions % 2 === 0);\r\n    } else { \r\n        if (blankRowFromBottom % 2 !== 0) { \r\n            isSolvable = (inversions % 2 === 0); \r\n        } else { \r\n            isSolvable = (inversions % 2 !== 0); \r\n        }\r\n    }\r\n\r\n    if (!isSolvable) {\r\n        let swapIndex1 = 0;\r\n        let swapIndex2 = 0;\r\n\r\n        if (shuffledPuzzle[0] !== numTiles - 1 && shuffledPuzzle[1] !== numTiles - 1) {\r\n            swapIndex1 = 0;\r\n            swapIndex2 = 1;\r\n        } else if (shuffledPuzzle[0] !== numTiles - 1 && shuffledPuzzle[2] !== numTiles - 1) {\r\n            swapIndex1 = 0;\r\n            swapIndex2 = 2;\r\n        } else {\r\n            let found = 0;\r\n            for (let i = 0; i < numTiles && found < 2; i++) {\r\n                if (shuffledPuzzle[i] !== numTiles - 1) {\r\n                    if (found === 0) {\r\n                        swapIndex1 = i;\r\n                    } else {\r\n                        swapIndex2 = i;\r\n                    }\r\n                    found++;\r\n                }\r\n            }\r\n        }\r\n        [shuffledPuzzle[swapIndex1], shuffledPuzzle[swapIndex2]] = [shuffledPuzzle[swapIndex2], shuffledPuzzle[swapIndex1]];\r\n    }\r\n\r\n    return shuffledPuzzle;\r\n}\r\n\r\n/**\r\n * Counts the number of inversions in a given puzzle array.\r\n * An inversion is a pair of tiles (a, b) where a appears before b, but a > b.\r\n * The blank tile (N*N - 1) is excluded from inversion counting.\r\n * @param {number[]} puzzle The current state of the puzzle tiles.\r\n * @returns {number} The total number of inversions.\r\n */\r\nfunction countInversions(puzzle) {\r\n    let inversions = 0;\r\n    const n = puzzle.length;\r\n    const blankTileValue = n - 1; // The value of the blank tile\r\n\r\n    for (let i = 0; i < n - 1; i++) {\r\n        if (puzzle[i] === blankTileValue) {\r\n            continue;\r\n        }\r\n        for (let j = i + 1; j < n; j++) {\r\n            if (puzzle[j] === blankTileValue) {\r\n                continue;\r\n            }\r\n            if (puzzle[i] > puzzle[j]) {\r\n                inversions++;\r\n            }\r\n        }\r\n    }\r\n    return inversions;\r\n}\r\n\r\n/**\r\n * Checks if the puzzle is in its solved state.\r\n * The solved state is when tiles are in ascending order (0, 1, 2, ..., N*N - 1).\r\n * @param {number[]} puzzle The current state of the puzzle tiles.\r\n * @param {number} level The size of one side of the square puzzle.\r\n * @returns {boolean} True if the puzzle is solved, false otherwise.\r\n */\r\nexport function isSolved(puzzle, level) {\r\n    const numTiles = level * level;\r\n    for (let i = 0; i < numTiles; i++) {\r\n        if (puzzle[i] !== i) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}